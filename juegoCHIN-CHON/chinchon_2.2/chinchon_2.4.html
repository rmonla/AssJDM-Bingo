<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chin Chón - Poker</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #006400; /* Verde oscuro mesa de juego */
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative; /* Para el scoreboard absoluto/fijo */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
        }

        .hand-area {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 130px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            flex-wrap: wrap;
            transition: background-color 0.3s, border 0.3s;
        }
        .player-hand.drag-over-draw-target {
            background-color: rgba(255, 215, 0, 0.3);
            border: 2px dashed #ffd700;
        }


        .cpu-hand .card {
            background-color: #4169E1;
            color: #4169E1;
            border: 1px solid #304D80;
        }
        .cpu-hand .card::before {
            content: "♤♧";
            color: #fff;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            opacity: 0.7;
        }
        .cpu-hand .card .value, .cpu-hand .card .suit {
            display: none;
        }

        .card {
            width: 70px;
            height: 100px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            margin: 5px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            cursor: grab;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative;
            font-size: 12px;
            color: #333;
            box-sizing: border-box;
        }
        .card.dragging {
            opacity: 0.5;
            transform: scale(1.05);
        }
        .dragging-source {
            opacity: 0.6 !important;
            border-style: dashed !important;
            border-color: #FFD700 !important;
        }

        .card.drag-over-placeholder {
            border: 2px dashed #ffd700;
            transform: translateY(-5px);
        }


        .card.selected {
            transform: translateY(-10px);
            box-shadow: 3px 13px 8px rgba(0,0,0,0.5);
        }
        .card.disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .card .value {
            font-size: 20px;
            font-weight: bold;
            line-height: 1;
        }
        .card .suit {
            font-size: 24px;
            line-height: 1;
        }
        .suit-Corazones, .suit-Diamantes { color: #FF0000; }
        .suit-Treboles, .suit-Picas { color: #000000; }


        .deck-pozo-area {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .deck-pile, .discard-pile {
            width: 80px;
            height: 110px;
            border: 2px dashed #fff;
            border-radius: 8px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            position: relative;
        }
        .deck-pile .card-count{
            position: absolute;
            bottom: -20px;
            font-size: 12px;
        }

        .deck-pile {
            background-color: #4169E1;
            /* cursor: pointer; ya no es necesario si solo es drag */
        }
        .discard-pile .card {
            margin: 0;
        }


        .actions, .game-messages {
            margin-bottom: 15px;
            text-align: center;
        }

        button {
            background-color: #FFD700;
            color: #333;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #F0C000;
        }
        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }

        .scoreboard {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 180px;
            background-color: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
            z-index: 100;
        }
        .scoreboard h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1em;
        }
        .scoreboard p {
            margin: 4px 0;
            font-size: 0.85em;
            display: flex;
            justify-content: space-between;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #2c3e50;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
            text-align: center;
        }
        .modal-content h3 { margin-top: 0; }
        .modal-content .modal-actions button { /* MODIFICADO: Estilo para botones en el modal */
             margin-top: 20px;
        }


        .round-summary-cards {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }
        .round-summary-cards .card {
            font-size: 8px;
            width: 50px;
            height: 70px;
        }
        .melded { border: 2px solid limegreen !important; }
        .unmelded { border: 2px solid crimson !important; }

    </style>
</head>
<body>
    <div class="scoreboard">
        <h2>Puntuación</h2>
        <p>Jugador: <span id="player-score">0</span></p>
        <p>CPU: <span id="cpu-score">0</span></p>
        <p>Ronda: <span id="round-number">1</span></p>
    </div>

    <div class="game-container">
        <h1>Chin Chón <small>(Poker)</small></h1>

        <div id="cpu-area">
            <h3>Mano CPU (<span id="cpu-card-count">0</span> cartas)</h3>
            <div class="hand-area cpu-hand" id="cpu-hand"></div>
        </div>

        <div class="deck-pozo-area">
            <div class="deck-pile" id="deck-pile" title="Arrastra para Robar del Mazo"> <!-- MODIFICADO: title -->
                MAZO
                <div class="card-count" id="deck-count">0</div>
            </div>
            <div class="discard-pile" id="discard-pile" title="Arrastra la carta para Robar del Pozo"> <!-- MODIFICADO: title -->
            </div>
        </div>
         <div class="game-messages" id="game-message">Turno del Jugador. Elige una acción.</div>

        <div id="player-area">
            <h3>Tu Mano (Arrastra para ordenar o robar aquí)</h3>
            <div class="hand-area player-hand" id="player-hand"></div>
        </div>

        <div class="actions">
            <!-- MODIFICADO: Botones de robar ocultos -->
            <button id="btn-draw-deck" onclick="playerDrawFromDeck()" style="display:none;">Robar del Mazo</button>
            <button id="btn-draw-discard" onclick="playerDrawFromDiscard()" style="display:none;">Robar del Pozo</button>
            <!-- Botón de descarte se mantiene -->
            <button id="btn-discard" onclick="playerConfirmDiscard()" disabled>Descartar Seleccionada</button>
            <button id="btn-close-round" onclick="playerAttemptClose()" disabled>Cerrar Ronda</button>
            <!-- Botones de siguiente ronda y nuevo juego se mueven al modal -->
            <button id="btn-next-round-dummy" style="display:none;" onclick="startNewRound()">Siguiente Ronda (dummy)</button>
            <button id="btn-new-game-dummy" style="display:none;" onclick="initGame()">Nuevo Juego (dummy)</button>
        </div>
    </div>

    <div id="round-summary-modal" class="modal">
        <div class="modal-content">
            <h3 id="round-summary-title">Fin de la Ronda</h3>
            <div id="round-summary-jugador">
                <h4>Jugador:</h4>
                <p>Puntos esta ronda: <span id="summary-player-points-round">0</span></p>
                <p>Combinaciones:</p>
                <div id="summary-player-melds" class="round-summary-cards"></div>
                <p>Cartas sueltas:</p>
                <div id="summary-player-unmelded" class="round-summary-cards"></div>
            </div>
            <hr>
            <div id="round-summary-cpu">
                <h4>CPU:</h4>
                <p>Puntos esta ronda: <span id="summary-cpu-points-round">0</span></p>
                 <p>Combinaciones:</p>
                <div id="summary-cpu-melds" class="round-summary-cards"></div>
                <p>Cartas sueltas:</p>
                <div id="summary-cpu-unmelded" class="round-summary-cards"></div>
            </div>
            <p id="round-winner-message"></p>
            <!-- MODIFICADO: Botones dentro del modal -->
            <div class="modal-actions">
                <button id="modal-btn-next-round" style="display:none;" onclick="handleNextRoundFromModal()">Siguiente Ronda</button>
                <button id="modal-btn-new-game" style="display:none;" onclick="handleNewGameFromModal()">Nuevo Juego</button>
                <button id="modal-btn-close" style="display:none;" onclick="closeModal()">Cerrar</button> <!-- Botón de cierre genérico si es necesario -->
            </div>
        </div>
    </div>


<script>
    // ... (Constantes y variables globales como estaban) ...
    const PALOS_POKER = ["Corazones", "Diamantes", "Treboles", "Picas"];
    const VALORES_DISPLAY_POKER = { 1: "A", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "J", 12: "Q", 13: "K" };
    const VALORES_NUMERICOS_POKER = { "A": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 11, "Q": 12, "K": 13 };
    const PUNTOS_CARTAS_POKER = { "A": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 10, "Q": 10, "K": 10 };

    const LIMITE_PUNTOS_PARTIDA = -100;
    const PUNTOS_CHINCHON = -25;
    const PUNTOS_CERRAR_CON_CERO = -10;
    const MAX_PUNTOS_PARA_CERRAR = 5;
    const PENALIZACION_CORTE_FALLIDO = 25;

    let mazo = [];
    let pozo = [];
    let manoJugador = [];
    let manoCPU = [];
    let puntuacionJugador = 0;
    let puntuacionCPU = 0;
    let rondaActual = 1;
    let turnoJugador = true;
    let jugadorHaRobado = false;
    let cartaSeleccionadaParaDescartar = null;
    let juegoTerminado = false;

    const playerHandElement = document.getElementById('player-hand');
    const cpuHandElement = document.getElementById('cpu-hand');
    const deckPileElement = document.getElementById('deck-pile');
    const discardPileElement = document.getElementById('discard-pile');
    const gameMessageElement = document.getElementById('game-message');
    const playerScoreElement = document.getElementById('player-score');
    const cpuScoreElement = document.getElementById('cpu-score');
    const roundNumberElement = document.getElementById('round-number');
    const deckCountElement = document.getElementById('deck-count');
    const cpuCardCountElement = document.getElementById('cpu-card-count');

    // Botones de acción principales (los de robar están ocultos)
    const btnDrawDeck = document.getElementById('btn-draw-deck');
    const btnDrawDiscard = document.getElementById('btn-draw-discard');
    const btnDiscard = document.getElementById('btn-discard');
    const btnCloseRound = document.getElementById('btn-close-round');
    
    // Botones del modal
    const roundSummaryModal = document.getElementById('round-summary-modal');
    const modalBtnNextRound = document.getElementById('modal-btn-next-round');
    const modalBtnNewGame = document.getElementById('modal-btn-new-game');
    const modalBtnClose = document.getElementById('modal-btn-close');


    let draggedItem = null;
    let placeholder = null;
    let draggedSourceType = null;


    class Carta {
        constructor(valorNum, palo) {
            this.valorNum = valorNum;
            this.palo = palo;
            this.nombreValor = VALORES_DISPLAY_POKER[valorNum];
            this.puntos = PUNTOS_CARTAS_POKER[this.nombreValor];
            this.id = `${this.nombreValor}-${this.palo}-${Math.random().toString(16).slice(2)}`;
        }
        toString() { return `${this.nombreValor} de ${this.palo}`; }
        getHTML() {
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card', `suit-${this.palo}`);
            cardDiv.dataset.id = this.id;
            cardDiv.dataset.valorNum = this.valorNum;
            cardDiv.dataset.palo = this.palo;
            const valorDisplay = this.nombreValor === "10" ? "10" : this.nombreValor.substring(0,1);
            cardDiv.innerHTML = `
                <span class="value">${valorDisplay}</span>
                <span class="suit">${getSuitSymbolPoker(this.palo)}</span>
                <span class="value">${valorDisplay}</span>
            `;
            return cardDiv;
        }
    }

    function getSuitSymbolPoker(palo) {
        if (palo === "Corazones") return '♥';
        if (palo === "Diamantes") return '♦';
        if (palo === "Treboles") return '♣';
        if (palo === "Picas") return '♠';
        return '?';
    }

    function crearBaraja() {
        mazo = [];
        for (const palo of PALOS_POKER) {
            for (const valorNum of Object.values(VALORES_NUMERICOS_POKER)) {
                 mazo.push(new Carta(valorNum, palo));
            }
        }
        for (let i = mazo.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [mazo[i], mazo[j]] = [mazo[j], mazo[i]];
        }
    }

    function repartirCartas() {
        manoJugador = [];
        manoCPU = [];
        pozo = [];
        for (let i = 0; i < 7; i++) {
            if (mazo.length > 0) manoJugador.push(mazo.pop());
            if (mazo.length > 0) manoCPU.push(mazo.pop());
        }
        if (mazo.length > 0) {
            pozo.push(mazo.pop());
        } else {
            console.error("Mazo vacío al intentar poner carta en el pozo inicial.");
        }
    }

    function renderizarMano(mano, element, esCPU = false) {
        element.innerHTML = '';
        mano.forEach(carta => {
            const cardElement = carta.getHTML();
            if (esCPU) {
                cardElement.onclick = null;
                cardElement.draggable = false;
            } else {
                cardElement.draggable = true;
                cardElement.addEventListener('dragstart', handleDragStartPlayerCard);
                cardElement.addEventListener('dragend', handleDragEndPlayerCard);
                if (jugadorHaRobado && turnoJugador) {
                    cardElement.onclick = () => seleccionarCartaParaDescartarDOM(carta, cardElement);
                } else {
                    cardElement.onclick = null;
                    if (cartaSeleccionadaParaDescartar && cartaSeleccionadaParaDescartar.id === carta.id) {
                        cardElement.classList.add('selected');
                    }
                }
            }
            element.appendChild(cardElement);
        });
        if (esCPU) {
            cpuCardCountElement.textContent = mano.length;
        }
    }

    function handleDragStartPlayerCard(e) {
        if (draggedSourceType) return;
        draggedItem = e.target;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', draggedItem.innerHTML);
        e.target.classList.add('dragging');
        if (!placeholder) {
            placeholder = document.createElement('div');
            placeholder.classList.add('card', 'drag-over-placeholder');
            placeholder.style.width = draggedItem.offsetWidth + 'px';
            placeholder.style.height = draggedItem.offsetHeight + 'px';
            placeholder.style.margin = getComputedStyle(draggedItem).margin;
        }
    }

    function handleDragEndPlayerCard(e) {
        if (!draggedItem) return;
        e.target.classList.remove('dragging');
        if (placeholder && placeholder.parentNode) {
            placeholder.parentNode.removeChild(placeholder);
        }
         if (e.dataTransfer.dropEffect === 'none' && draggedItem) {
            draggedItem = null;
         }
    }
    
    playerHandElement.addEventListener('dragover', handleDragOverPlayerHand);
    playerHandElement.addEventListener('dragenter', handleDragEnterPlayerHand);
    playerHandElement.addEventListener('dragleave', handleDragLeavePlayerHand);
    playerHandElement.addEventListener('drop', handleDropOnPlayerHand);

    function handleDragOverPlayerHand(e) {
        e.preventDefault();
        if (draggedItem) {
            e.dataTransfer.dropEffect = 'move';
            const afterElement = getDragAfterElementInPlayerHand(playerHandElement, e.clientX);
            if (afterElement == null) {
                if (!placeholder.parentNode || placeholder.nextSibling != null) {
                    playerHandElement.appendChild(placeholder);
                }
            } else {
                 if (!placeholder.parentNode || placeholder.nextSibling != afterElement) {
                    playerHandElement.insertBefore(placeholder, afterElement);
                 }
            }
        } else if (draggedSourceType === 'deck' || draggedSourceType === 'discard') {
            if (turnoJugador && !jugadorHaRobado && !juegoTerminado) {
                e.dataTransfer.dropEffect = 'move';
                playerHandElement.classList.add('drag-over-draw-target');
            } else {
                e.dataTransfer.dropEffect = 'none';
            }
        }
    }

    function handleDragEnterPlayerHand(e) {
        e.preventDefault();
        if (draggedSourceType === 'deck' || draggedSourceType === 'discard') {
            if (turnoJugador && !jugadorHaRobado && !juegoTerminado) {
                playerHandElement.classList.add('drag-over-draw-target');
            }
        }
    }
    function handleDragLeavePlayerHand(e) {
        if (e.target === playerHandElement) {
             playerHandElement.classList.remove('drag-over-draw-target');
        }
    }

    function handleDropOnPlayerHand(e) {
        e.preventDefault();
        playerHandElement.classList.remove('drag-over-draw-target');

        if (draggedItem) {
            const draggedCardId = draggedItem.dataset.id;
            const draggedCardIndex = manoJugador.findIndex(c => c.id === draggedCardId);
            if (draggedCardIndex === -1) {
                draggedItem.classList.remove('dragging');
                draggedItem = null;
                return;
            }
            const [movedCard] = manoJugador.splice(draggedCardIndex, 1);
            let newIndex = -1;
            if (placeholder && placeholder.parentNode === playerHandElement) {
                newIndex = Array.from(playerHandElement.children).indexOf(placeholder);
            } else {
                const afterElement = getDragAfterElementInPlayerHand(playerHandElement, e.clientX);
                if (afterElement === null) { newIndex = manoJugador.length; }
                else { const targetCardId = afterElement.dataset.id; newIndex = manoJugador.findIndex(c => c.id === targetCardId); }
            }
            if (newIndex === -1) newIndex = manoJugador.length;
            manoJugador.splice(newIndex, 0, movedCard);
            if (placeholder && placeholder.parentNode) { placeholder.parentNode.removeChild(placeholder); }
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            actualizarUI();
        
        } else if (draggedSourceType) {
            if (turnoJugador && !jugadorHaRobado && !juegoTerminado) {
                if (draggedSourceType === 'deck' && mazo.length > 0) {
                    playerDrawFromDeck();
                } else if (draggedSourceType === 'discard' && pozo.length > 0) {
                    playerDrawFromDiscard();
                }
            }
        }
    }

    function getDragAfterElementInPlayerHand(container, x) {
        const draggableElements = [...container.querySelectorAll('.card:not(.dragging):not(.drag-over-placeholder)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = x - box.left - box.width / 2;
            if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; }
            else { return closest; }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function handleDeckDragStart(e) {
        if (!turnoJugador || jugadorHaRobado || mazo.length === 0 || juegoTerminado) { e.preventDefault(); return; }
        draggedSourceType = 'deck';
        e.dataTransfer.setData('text/plain', 'draw_from_deck');
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging-source');
    }
    function handleDeckDragEnd(e) {
        draggedSourceType = null;
        e.target.classList.remove('dragging-source');
        playerHandElement.classList.remove('drag-over-draw-target');
    }

    function handleDiscardCardDragStart(e) {
         if (!turnoJugador || jugadorHaRobado || pozo.length === 0 || juegoTerminado) { e.preventDefault(); return; }
        if (!e.target.classList.contains('card')) { e.preventDefault(); return; }
        draggedSourceType = 'discard';
        e.dataTransfer.setData('text/plain', 'draw_from_discard');
        e.dataTransfer.effectAllowed = 'move';
        e.target.classList.add('dragging-source');
    }
    function handleDiscardCardDragEnd(e) {
        draggedSourceType = null;
        if (e.target.classList.contains('card')) { e.target.classList.remove('dragging-source'); }
        playerHandElement.classList.remove('drag-over-draw-target');
    }
    
    deckPileElement.addEventListener('dragstart', handleDeckDragStart);
    deckPileElement.addEventListener('dragend', handleDeckDragEnd);

    function renderizarPozo() {
        discardPileElement.innerHTML = '';
        if (pozo.length > 0) {
            const topCard = pozo[pozo.length - 1];
            const cardElement = topCard.getHTML();
            cardElement.onclick = null;
            if (turnoJugador && !jugadorHaRobado && !juegoTerminado) {
                cardElement.draggable = true;
                cardElement.addEventListener('dragstart', handleDiscardCardDragStart);
                cardElement.addEventListener('dragend', handleDiscardCardDragEnd);
            } else { cardElement.draggable = false; }
            discardPileElement.appendChild(cardElement);
        } else {
            discardPileElement.textContent = "Vacío";
        }
    }

    function renderizarMazo() {
        deckCountElement.textContent = mazo.length;
        deckPileElement.style.display = mazo.length > 0 ? 'flex' : 'none';
        if (turnoJugador && !jugadorHaRobado && mazo.length > 0 && !juegoTerminado) {
            deckPileElement.draggable = true;
            deckPileElement.style.cursor = 'grab';
        } else {
            deckPileElement.draggable = false;
            deckPileElement.style.cursor = 'default'; // Ya no es 'pointer' porque no hay click para robar
        }
    }

    function actualizarUI() {
        renderizarMano(manoJugador, playerHandElement);
        renderizarMano(manoCPU, cpuHandElement, true);
        renderizarPozo();
        renderizarMazo();
        playerScoreElement.textContent = puntuacionJugador;
        cpuScoreElement.textContent = puntuacionCPU;
        roundNumberElement.textContent = rondaActual;

        const puedeRobar = turnoJugador && !jugadorHaRobado && !juegoTerminado;
        // Los botones de robar están display:none, no es necesario cambiar su 'disabled'
        // btnDrawDeck.disabled = !puedeRobar || mazo.length === 0;
        // btnDrawDiscard.disabled = !puedeRobar || pozo.length === 0;
        
        btnDiscard.disabled = !turnoJugador || !jugadorHaRobado || !cartaSeleccionadaParaDescartar || juegoTerminado;

        let puedeCerrarConDescarte = false;
        if (jugadorHaRobado && manoJugador.length === 8) {
            for (const carta of manoJugador) {
                const manoTemporal = manoJugador.filter(c => c.id !== carta.id);
                const evalTemporal = evaluarManoCompleto(manoTemporal);
                if (evalTemporal.esChinchon || evalTemporal.puntosSueltos <= MAX_PUNTOS_PARA_CERRAR) {
                    puedeCerrarConDescarte = true;
                    break;
                }
            }
        }
        btnCloseRound.disabled = !turnoJugador || !jugadorHaRobado || !puedeCerrarConDescarte || juegoTerminado;
        if (jugadorHaRobado && manoJugador.length === 8 && esChinChonConDescarte(manoJugador)) {
             btnCloseRound.disabled = false;
        }
    }
    
    function esChinChonConDescarte(manoCon8Cartas) {
        if (manoCon8Cartas.length !== 8) return false;
        for (let i = 0; i < manoCon8Cartas.length; i++) {
            const manoTemporal = manoCon8Cartas.filter((_, idx) => idx !== i);
            if (esChinChon(manoTemporal)) return true;
        }
        return false;
    }

    function seleccionarCartaParaDescartarDOM(carta, cardElement) {
        if (!jugadorHaRobado || !turnoJugador) return;
        if (cartaSeleccionadaParaDescartar && cartaSeleccionadaParaDescartar.id === carta.id) {
            cartaSeleccionadaParaDescartar = null;
            cardElement.classList.remove('selected');
            btnDiscard.disabled = true;
        } else {
            if (cartaSeleccionadaParaDescartar) {
                const prevSelectedDOM = playerHandElement.querySelector(`.card[data-id="${cartaSeleccionadaParaDescartar.id}"]`);
                if (prevSelectedDOM) prevSelectedDOM.classList.remove('selected');
            }
            cartaSeleccionadaParaDescartar = carta;
            cardElement.classList.add('selected');
            btnDiscard.disabled = false;
        }
    }

    function playerDrawFromDeck() {
        if (!turnoJugador || jugadorHaRobado || mazo.length === 0 || juegoTerminado) return;
        const cartaRobada = mazo.pop();
        manoJugador.push(cartaRobada);
        jugadorHaRobado = true;
        gameMessageElement.textContent = "Has robado del mazo. Selecciona una carta para descartar o cierra la ronda.";
        actualizarUI();
    }

    function playerDrawFromDiscard() {
        if (!turnoJugador || jugadorHaRobado || pozo.length === 0 || juegoTerminado) return;
        const cartaRobada = pozo.pop();
        manoJugador.push(cartaRobada);
        jugadorHaRobado = true;
        gameMessageElement.textContent = "Has robado del pozo. Selecciona una carta para descartar o cierra la ronda.";
        actualizarUI();
    }

    function playerConfirmDiscard() {
        if (!cartaSeleccionadaParaDescartar || !jugadorHaRobado || manoJugador.length !== 8) return;
        const index = manoJugador.findIndex(c => c.id === cartaSeleccionadaParaDescartar.id);
        if (index > -1) {
            const [cartaDescartada] = manoJugador.splice(index, 1);
            pozo.push(cartaDescartada);
            const { puntosSueltos: puntosJugadorPostDescarte, esChinchon } = evaluarManoCompleto(manoJugador);
            let mensaje = `Has descartado ${cartaDescartada}. `;

            if (esChinchon) { mensaje += "¡Tienes ChinChón! Puedes cerrar la ronda."; }
            else if (puntosJugadorPostDescarte <= MAX_PUNTOS_PARA_CERRAR) { mensaje += `Puedes cerrar con ${puntosJugadorPostDescarte} puntos.`; }
            else { mensaje += "Turno de la CPU."; }
            gameMessageElement.textContent = mensaje;
            
            cartaSeleccionadaParaDescartar = null;
            jugadorHaRobado = false; 
            actualizarUI(); 
            
            const puedeCerrarAhora = esChinchon || puntosJugadorPostDescarte <= MAX_PUNTOS_PARA_CERRAR;
            if (puedeCerrarAhora) {
                if (confirm("¿Quieres cerrar la ronda AHORA con estas 7 cartas? (También puedes usar el botón 'Cerrar Ronda' si prefieres)")) {
                    finalizarRonda("Jugador", esChinchon);
                } else {
                    cambiarTurno();
                }
            } else {
                cambiarTurno();
            }
        }
    }
        
    function playerAttemptClose() {
        if (!turnoJugador || !jugadorHaRobado || manoJugador.length !== 8) {
            alert("Debes robar una carta (tener 8) y luego seleccionar una para descartar al cerrar.");
            return;
        }
        if (!cartaSeleccionadaParaDescartar) {
            alert("Debes seleccionar una carta para descartar para poder cerrar la ronda (cerrarás con las 7 restantes).");
            return;
        }
        const manoTemporalParaCerrar = manoJugador.filter(c => c.id !== cartaSeleccionadaParaDescartar.id);
        const { esChinchon, puntosSueltos } = evaluarManoCompleto(manoTemporalParaCerrar);

        if (esChinchon) {
            const index = manoJugador.findIndex(c => c.id === cartaSeleccionadaParaDescartar.id);
            const [cartaDescartada] = manoJugador.splice(index, 1);
            pozo.push(cartaDescartada);
            gameMessageElement.textContent = `¡CHINCHÓN! Descartaste ${cartaDescartada.toString()} y cerraste.`;
            finalizarRondaYLimpiar("Jugador", true);
        } else if (puntosSueltos <= MAX_PUNTOS_PARA_CERRAR) {
            const index = manoJugador.findIndex(c => c.id === cartaSeleccionadaParaDescartar.id);
            const [cartaDescartada] = manoJugador.splice(index, 1);
            pozo.push(cartaDescartada);
            gameMessageElement.textContent = `Cerraste con ${puntosSueltos} puntos después de descartar ${cartaDescartada.toString()}.`;
            finalizarRondaYLimpiar("Jugador", false);
        } else {
            alert("No puedes cerrar. Tus 7 cartas restantes tras el descarte seleccionado sumarían más de " + MAX_PUNTOS_PARA_CERRAR + " puntos.");
        }
    }

    function finalizarRondaYLimpiar(cerrador, hizoChinchon) {
        cartaSeleccionadaParaDescartar = null;
        jugadorHaRobado = false;
        finalizarRonda(cerrador, hizoChinchon);
    }

    function cambiarTurno() {
        turnoJugador = !turnoJugador;
        jugadorHaRobado = false;
        cartaSeleccionadaParaDescartar = null;
        const selectedDOM = playerHandElement.querySelector('.card.selected');
        if (selectedDOM) selectedDOM.classList.remove('selected');

        if (!turnoJugador) {
            gameMessageElement.textContent = "Turno de la CPU...";
            actualizarUI();
            setTimeout(turnoCPU, 1500);
        } else {
            gameMessageElement.textContent = "Tu turno. Arrastra una carta del mazo o pozo a tu mano."; // MODIFICADO mensaje
            revisarMazoPozo();
            actualizarUI();
        }
    }

    function revisarMazoPozo() {
        if (mazo.length === 0 && pozo.length > 1) {
            gameMessageElement.textContent = "El mazo se acabó. Barajando el pozo...";
            const ultimaPozo = pozo.pop();
            mazo = [...pozo];
            pozo = [ultimaPozo];
            for (let i = mazo.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [mazo[i], mazo[j]] = [mazo[j], mazo[i]];
            }
            renderizarMazo();
            gameMessageElement.textContent = "Mazo repuesto con el pozo. " + (turnoJugador ? "Tu turno." : "Turno de la CPU.");
        } else if (mazo.length === 0 && pozo.length <=1) {
            gameMessageElement.textContent = "¡No hay más cartas para robar! Ronda en empate técnico.";
            finalizarRonda(null, false, true);
        }
    }

    function ordenarMano(mano) {
        return mano.slice().sort((a, b) => {
            if (a.palo < b.palo) return -1;
            if (a.palo > b.palo) return 1;
            return a.valorNum - b.valorNum;
        });
    }

    function obtenerCombinacionesPosibles(mano) {
        const combinaciones = []; const manoCopia = mano.slice();
        manoCopia.sort((a, b) => {
            if (a.palo < b.palo) return -1; if (a.palo > b.palo) return 1;
            return a.valorNum - b.valorNum;
        });
        for (let i = 0; i < manoCopia.length; i++) {
            let escaleraActual = [manoCopia[i]];
            for (let j = i + 1; j < manoCopia.length; j++) {
                if (manoCopia[j].palo === escaleraActual[0].palo && manoCopia[j].valorNum === escaleraActual[escaleraActual.length - 1].valorNum + 1) {
                    escaleraActual.push(manoCopia[j]);
                } else if (manoCopia[j].palo !== escaleraActual[0].palo || manoCopia[j].valorNum > escaleraActual[escaleraActual.length - 1].valorNum + 1) { break; }
            }
            if (escaleraActual.length >= 3) {
                for (let len = 3; len <= escaleraActual.length; len++) {
                    for (let start = 0; start <= escaleraActual.length - len; start++) { combinaciones.push(escaleraActual.slice(start, start + len)); }
                }
            }
        }
        const cartasPorValor = {};
        mano.forEach(carta => { if (!cartasPorValor[carta.valorNum]) cartasPorValor[carta.valorNum] = []; cartasPorValor[carta.valorNum].push(carta); });
        for (const valor in cartasPorValor) {
            if (cartasPorValor[valor].length >= 3) { combinaciones.push(cartasPorValor[valor].slice(0, 3)); }
            if (cartasPorValor[valor].length === 4) { combinaciones.push(cartasPorValor[valor].slice(0, 4)); }
        }
        let combinacionesUnicas = []; combinaciones.sort((a,b) => b.length - a.length);
        for (const comb of combinaciones) {
            let esSubconjunto = false;
            for (const unica of combinacionesUnicas) { if (comb.every(c => unica.find(u => u.id === c.id))) { esSubconjunto = true; break; } }
            if (!esSubconjunto) { combinacionesUnicas.push(comb); }
        }
        return combinacionesUnicas;
    }

    function evaluarManoCompleto(mano) {
        if (mano.length === 0) return { combinacionesElegidas: [], cartasSueltas: [], puntosSueltos: 0, esChinchon: false };
        const chinchon = esChinChon(mano);
        if (chinchon) return { combinacionesElegidas: [ordenarMano(mano.slice())], cartasSueltas: [], puntosSueltos: 0, esChinchon: true };
        let mejorResultado = { combinacionesElegidas: [], cartasSueltas: mano.slice(), puntosSueltos: mano.reduce((sum, c) => sum + c.puntos, 0), esChinchon: false };
        const todasCombinaciones = obtenerCombinacionesPosibles(mano.slice());
        function encontrarMejorConfig(idx, usadasIds, config) {
            if (idx === todasCombinaciones.length) {
                let sueltas = mano.filter(c => !usadasIds.has(c.id));
                let puntos = sueltas.reduce((sum, c) => sum + c.puntos, 0);
                if (puntos < mejorResultado.puntosSueltos || (puntos === mejorResultado.puntosSueltos && config.reduce((s, m) => s + m.length, 0) > mejorResultado.combinacionesElegidas.reduce((s, m) => s + m.length, 0))) {
                    mejorResultado = { combinacionesElegidas: config.slice(), cartasSueltas: sueltas, puntosSueltos: puntos, esChinchon: false };
                } return;
            }
            encontrarMejorConfig(idx + 1, new Set(usadasIds), config.slice());
            const combActual = todasCombinaciones[idx];
            if (combActual.every(c => !usadasIds.has(c.id))) {
                const nuevasUsadasIds = new Set(usadasIds); combActual.forEach(c => nuevasUsadasIds.add(c.id));
                const nuevaConfig = config.slice(); nuevaConfig.push(combActual);
                encontrarMejorConfig(idx + 1, nuevasUsadasIds, nuevaConfig);
            }
        }
        if(todasCombinaciones.length > 0) encontrarMejorConfig(0, new Set(), []);
        return mejorResultado;
    }

    function esChinChon(mano) {
        if (mano.length !== 7) return false;
        const manoOrd = ordenarMano(mano.slice()); const primerPalo = manoOrd[0].palo;
        for (let i = 0; i < manoOrd.length; i++) {
            if (manoOrd[i].palo !== primerPalo) return false;
            if (i > 0 && manoOrd[i].valorNum !== manoOrd[i-1].valorNum + 1) return false;
        } return true;
    }

    function cpuDecideRobar(manoCpu, cartaPozo) {
        if (!cartaPozo) return "mazo";
        if (manoCpu.length === 6) { const tempMano = [...manoCpu, cartaPozo]; if (esChinChon(tempMano)) return "pozo"; }
        const { puntosSueltos: actual } = evaluarManoCompleto(manoCpu);
        let mejorConPozo = Infinity; const manoConPozo = [...manoCpu, cartaPozo];
        if (manoConPozo.length > 7) {
            for (let i = 0; i < manoConPozo.length; i++) {
                const tempEval = manoConPozo.filter((_, idx) => idx !== i);
                const { puntosSueltos: tempP } = evaluarManoCompleto(tempEval);
                if (tempP < mejorConPozo) mejorConPozo = tempP;
            }
        } else { const { puntosSueltos: tempP } = evaluarManoCompleto(manoConPozo); mejorConPozo = tempP; }
        if (mejorConPozo <= MAX_PUNTOS_PARA_CERRAR && actual > MAX_PUNTOS_PARA_CERRAR) return "pozo";
        if (mejorConPozo < actual - 3) return "pozo";
        return "mazo";
    }

    function cpuEligeDescarte(manoCpu8) {
        let cartaADescartar = null; let minPuntos = Infinity;
        if (manoCpu8.length <= 1) return manoCpu8[0];
        for (let i = 0; i < manoCpu8.length; i++) {
            const tempMano7 = manoCpu8.filter((_, idx) => idx !== i);
            if (esChinChon(tempMano7)) return manoCpu8[i];
        }
        for (let i = 0; i < manoCpu8.length; i++) {
            const potDescarte = manoCpu8[i]; const tempMano7 = manoCpu8.filter(c => c.id !== potDescarte.id);
            const { puntosSueltos } = evaluarManoCompleto(tempMano7);
            if (puntosSueltos < minPuntos) {
                minPuntos = puntosSueltos; cartaADescartar = potDescarte;
            } else if (puntosSueltos === minPuntos) {
                if (cartaADescartar === null || potDescarte.puntos > cartaADescartar.puntos) cartaADescartar = potDescarte;
            }
        }
        return cartaADescartar || manoCpu8[Math.floor(Math.random() * manoCpu8.length)];
    }

    function turnoCPU() {
        if (juegoTerminado) return;
        gameMessageElement.textContent = "CPU está pensando...";
        setTimeout(() => {
            revisarMazoPozo();
            if (mazo.length === 0 && pozo.length <= 1 && !turnoJugador) { finalizarRonda(null, false, true); return; }
            const cartaDelPozo = pozo.length > 0 ? pozo[pozo.length - 1] : null;
            const decisionRobo = cpuDecideRobar(manoCPU, cartaDelPozo);
            let cartaRobadaCPU;
            if (decisionRobo === "pozo" && cartaDelPozo && pozo.length > 0) {
                cartaRobadaCPU = pozo.pop(); gameMessageElement.textContent = `CPU ha robado ${cartaRobadaCPU.toString()} del pozo.`;
            } else {
                if (mazo.length === 0) {
                     if (cartaDelPozo && pozo.length > 0) { cartaRobadaCPU = pozo.pop(); gameMessageElement.textContent = `CPU ha robado ${cartaRobadaCPU.toString()} del pozo (mazo vacío).`; }
                     else { finalizarRonda(null, false, true); return; }
                } else { cartaRobadaCPU = mazo.pop(); gameMessageElement.textContent = "CPU ha robado del mazo."; }
            }
            manoCPU.push(cartaRobadaCPU);
            setTimeout(() => {
                const cartaDescartadaCPU = cpuEligeDescarte(manoCPU);
                const index = manoCPU.findIndex(c => c.id === cartaDescartadaCPU.id);
                if (index > -1) {
                    manoCPU.splice(index, 1); pozo.push(cartaDescartadaCPU);
                    gameMessageElement.textContent = `CPU ha descartado ${cartaDescartadaCPU.toString()}.`;
                } else {
                    if (manoCPU.length > 7) { const fallback = manoCPU.pop(); pozo.push(fallback); gameMessageElement.textContent = `CPU ha descartado (fallback) ${fallback.toString()}.`; }
                    else if (manoCPU.length === 0) { console.error("Mano CPU vacía"); cambiarTurno(); return; }
                }
                const { esChinchon: cpuChinchon, puntosSueltos: puntosCPU } = evaluarManoCompleto(manoCPU);
                if (cpuChinchon) { finalizarRondaYLimpiar("CPU", true); }
                else if (puntosCPU <= MAX_PUNTOS_PARA_CERRAR - 2 && manoCPU.length === 7) { finalizarRondaYLimpiar("CPU", false); }
                else { cambiarTurno(); }
            }, 1000);
        }, 1000);
    }

    function finalizarRonda(cerrador, hizoChinchon, empateTecnico = false) {
        // Deshabilitar acciones de juego
        btnDiscard.disabled = true;
        btnCloseRound.disabled = true;
        // Los botones de robar ya están ocultos/no interactivos para el jugador
        // pero la lógica de arrastre debe prevenirse si la ronda terminó
        // Esto se maneja con 'juegoTerminado' o !turnoJugador en los handlers de drag

        let evalJugador = evaluarManoCompleto(manoJugador);
        let evalCPU = evaluarManoCompleto(manoCPU);
        let puntosRondaJugador = evalJugador.puntosSueltos;
        let puntosRondaCPU = evalCPU.puntosSueltos;
        let mensajeGanadorRonda = "";

        if (empateTecnico) {
            puntuacionJugador += puntosRondaJugador; puntuacionCPU += puntosRondaCPU;
            mensajeGanadorRonda = "Ronda en empate técnico. Se suman los puntos de las manos.";
        } else if (cerrador === "Jugador") {
            if (hizoChinchon) { puntosRondaJugador = PUNTOS_CHINCHON; mensajeGanadorRonda = "¡Jugador hizo ChinChón!"; }
            else {
                puntosRondaJugador = (puntosRondaJugador === 0) ? PUNTOS_CERRAR_CON_CERO : puntosRondaJugador;
                if (evalCPU.esChinchon || (puntosRondaCPU < evalJugador.puntosSueltos && !evalJugador.esChinchon)) {
                    puntosRondaJugador = PENALIZACION_CORTE_FALLIDO;
                    mensajeGanadorRonda = `Jugador cerró, pero CPU tenía menos (${puntosRondaCPU}) o Chinchón. ¡Penalización para Jugador!`;
                } else { mensajeGanadorRonda = `Jugador cerró con ${evalJugador.puntosSueltos} puntos.`; }
            }
            puntuacionJugador += puntosRondaJugador;
            puntuacionCPU += (evalCPU.esChinchon && cerrador !== "CPU") ? PUNTOS_CHINCHON : evalCPU.puntosSueltos; // CPU suma sus puntos o chinchon
        } else if (cerrador === "CPU") {
            if (hizoChinchon) { puntosRondaCPU = PUNTOS_CHINCHON; mensajeGanadorRonda = "¡CPU hizo ChinChón!"; }
            else {
                puntosRondaCPU = (puntosRondaCPU === 0) ? PUNTOS_CERRAR_CON_CERO : puntosRondaCPU;
                if (evalJugador.esChinchon || (puntosRondaJugador < evalCPU.puntosSueltos && !evalCPU.esChinchon)) {
                    puntosRondaCPU = PENALIZACION_CORTE_FALLIDO;
                    mensajeGanadorRonda = `CPU cerró, pero Jugador tenía menos (${puntosRondaJugador}) o Chinchón. ¡Penalización para CPU!`;
                } else { mensajeGanadorRonda = `CPU cerró con ${evalCPU.puntosSueltos} puntos.`; }
            }
            puntuacionCPU += puntosRondaCPU;
            puntuacionJugador += (evalJugador.esChinchon && cerrador !== "Jugador") ? PUNTOS_CHINCHON : evalJugador.puntosSueltos;
        }
        
        document.getElementById('summary-player-points-round').textContent = `${evalJugador.puntosSueltos}`;
        mostrarCartasEnResumen('summary-player-melds', evalJugador.combinacionesElegidas, true);
        mostrarCartasEnResumen('summary-player-unmelded', evalJugador.cartasSueltas, false);
        document.getElementById('summary-cpu-points-round').textContent = `${evalCPU.puntosSueltos}`;
        mostrarCartasEnResumen('summary-cpu-melds', evalCPU.combinacionesElegidas, true);
        mostrarCartasEnResumen('summary-cpu-unmelded', evalCPU.cartasSueltas, false);
        document.getElementById('round-winner-message').textContent = mensajeGanadorRonda;
        
        // Controlar botones del modal
        modalBtnNextRound.style.display = 'none';
        modalBtnNewGame.style.display = 'none';
        modalBtnClose.style.display = 'none'; // Ocultar por defecto

        verificarFinPartida(); // Esto setea juegoTerminado

        if (juegoTerminado) {
            modalBtnNewGame.style.display = 'inline-block';
        } else {
            modalBtnNextRound.style.display = 'inline-block';
        }
        roundSummaryModal.style.display = "flex";
        actualizarUI(); // Solo para reflejar puntuaciones finales, botones ya están manejados.
    }
    
    function mostrarCartasEnResumen(elementId, items, esMelded) {
        const container = document.getElementById(elementId); container.innerHTML = '';
        if (!items || items.length === 0) { container.innerHTML = "<p style='font-style: italic; font-size: 0.9em; margin: 5px 0;'>Ninguna</p>"; return; }
        if (esMelded) {
            items.forEach(grupo => {
                 const groupDiv = document.createElement('div');
                 groupDiv.style.marginRight = '10px'; groupDiv.style.marginBottom = '5px';
                 groupDiv.style.border = '1px solid #555'; groupDiv.style.padding = '3px'; groupDiv.style.borderRadius = '4px';
                 grupo.forEach(carta => { const cardEl = carta.getHTML(); cardEl.classList.add('melded'); cardEl.onclick = null; cardEl.draggable = false; groupDiv.appendChild(cardEl); });
                 container.appendChild(groupDiv);
            });
        } else {
            items.forEach(carta => { const cardEl = carta.getHTML(); cardEl.classList.add('unmelded'); cardEl.onclick = null; cardEl.draggable = false; container.appendChild(cardEl); });
        }
    }

    // NUEVO: Handlers para botones del modal
    function handleNextRoundFromModal() {
        startNewRound();
        roundSummaryModal.style.display = "none";
    }

    function handleNewGameFromModal() {
        initGame();
        roundSummaryModal.style.display = "none";
    }
    
    function closeModal() { // Si se usa el botón "Cerrar" genérico
        roundSummaryModal.style.display = "none";
        // Si el juego terminó y se cierra el modal sin presionar "Nuevo Juego",
        // el mensaje de "Presiona Nuevo Juego" podría aparecer afuera si se desea.
        if (juegoTerminado) {
            gameMessageElement.textContent += " --- Presiona 'Nuevo Juego' (en el próximo resumen o reinicia la página) para empezar otra vez.";
        }
    }


    function verificarFinPartida() {
        if (puntuacionJugador <= LIMITE_PUNTOS_PARTIDA || puntuacionCPU <= LIMITE_PUNTOS_PARTIDA) {
            juegoTerminado = true;
            let mensajeFinal = "¡Fin de la Partida! ";
            if (puntuacionJugador <= LIMITE_PUNTOS_PARTIDA && puntuacionCPU > LIMITE_PUNTOS_PARTIDA) {
                mensajeFinal = `¡Fin de la Partida! Superaste el límite. ¡GANA LA CPU! (${puntuacionCPU} a ${puntuacionJugador})`;
            } else if (puntuacionCPU <= LIMITE_PUNTOS_PARTIDA && puntuacionJugador > LIMITE_PUNTOS_PARTIDA) {
                mensajeFinal = `¡Fin de la Partida! CPU superó el límite. ¡GANASTE! (${puntuacionJugador} a ${puntuacionCPU})`;
            } else if (puntuacionCPU <= LIMITE_PUNTOS_PARTIDA && puntuacionJugador <= LIMITE_PUNTOS_PARTIDA) {
                 if (puntuacionJugador > puntuacionCPU) mensajeFinal = `¡Fin de la Partida! Ambos superaron límite. ¡GANASTE! (${puntuacionJugador} a ${puntuacionCPU})`;
                 else if (puntuacionCPU > puntuacionJugador) mensajeFinal = `¡Fin de la Partida! Ambos superaron límite. ¡GANA LA CPU! (${puntuacionCPU} a ${puntuacionJugador})`;
                 else mensajeFinal = `¡Fin de la Partida! Ambos superaron límite. ¡EMPATE! (${puntuacionJugador} a ${puntuacionCPU})`;
            } else { // Ninguno cruzó el límite, pero uno ganó por puntos al cerrar (esto no debería ser el caso aquí, ya que el límite es el trigger)
                 if (puntuacionJugador < puntuacionCPU) mensajeFinal += "¡GANASTE!";
                 else if (puntuacionCPU < puntuacionJugador) mensajeFinal += "¡GANA LA CPU!";
                 else mensajeFinal += "¡EMPATE EN LA PARTIDA!";
            }
            gameMessageElement.textContent = mensajeFinal;
            // Los botones del modal se manejan en finalizarRonda
        }
    }

    function startNewRound() {
        if (juegoTerminado && rondaActual > 0) { // Prevenir iniciar nueva ronda si el juego terminó, excepto en initGame
             console.log("El juego ha terminado. Inicia un nuevo juego.");
             // Asegurar que los botones de acción principal estén deshabilitados
             btnDiscard.disabled = true;
             btnCloseRound.disabled = true;
             return;
        }
        rondaActual++;
        mazo = []; pozo = []; manoJugador = []; manoCPU = [];
        jugadorHaRobado = false; cartaSeleccionadaParaDescartar = null;
        turnoJugador = (rondaActual % 2 === 1);

        crearBaraja();
        repartirCartas();

        gameMessageElement.textContent = turnoJugador ? "Tu turno. Arrastra una carta del mazo o pozo a tu mano." : "Turno de la CPU...";
        // Los botones de acción se habilitan/deshabilitan en actualizarUI
        actualizarUI();

        if (!turnoJugador) setTimeout(turnoCPU, 1500);
    }

    function initGame() {
        puntuacionJugador = 0; puntuacionCPU = 0; rondaActual = 0; // Se incrementará a 1 en startNewRound
        juegoTerminado = false;
        
        document.getElementById('summary-player-points-round').textContent = "0";
        document.getElementById('summary-player-melds').innerHTML = "Ninguna";
        document.getElementById('summary-player-unmelded').innerHTML = "Ninguna";
        document.getElementById('summary-cpu-points-round').textContent = "0";
        document.getElementById('summary-cpu-melds').innerHTML = "Ninguna";
        document.getElementById('summary-cpu-unmelded').innerHTML = "Ninguna";
        document.getElementById('round-winner-message').textContent = "";
        
        startNewRound();
    }

    window.onload = initGame;

</script>
</body>
</html>