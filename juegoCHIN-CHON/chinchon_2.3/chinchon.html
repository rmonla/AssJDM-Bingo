<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chin Chón - Poker (SVG Cards)</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #006400;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative;
            overflow-x: hidden;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
        }

        .hand-area, .discard-pile-target {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 130px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            flex-wrap: wrap;
        }
        .player-hand-container.drag-over {
             background-color: rgba(0, 0, 0, 0.3);
             border: 2px dashed #FFD700;
        }
        .discard-pile-target.drag-over {
            background-color: rgba(255, 0, 0, 0.2);
            border: 2px dashed #FF6347;
        }

        .card {
            width: 75px;
            height: 110px;
            margin: 5px;
            cursor: grab;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative;
            user-select: none;
            background-color: transparent;
            border: none;
            /* box-shadow: 2px 2px 5px rgba(0,0,0,0.3); No es necesario si el SVG tiene su propio sombreado o no queremos */
            border-radius: 5px; /* SVGs pueden tener su propio radio */
        }
        .card img { /* Usaremos <img> para SVGs también, es más fácil */
            width: 100%;
            height: 100%;
            display: block;
            /* border-radius: 5px; Los SVGs suelen tener su propio path para el borde */
        }

        .card.dragging { opacity: 0.7; transform: scale(1.05) rotate(3deg); }
        .card.placeholder {
            width: 75px;
            height: 110px;
            border: 2px dashed #aaa;
            background: rgba(255,255,255,0.05);
            margin: 5px;
            border-radius: 5px;
            box-sizing: border-box;
        }

        .deck-pozo-area { /* Sin cambios */ }
        .deck-pile-container, .discard-pile-container { /* Sin cambios */ }
        .deck-pile-container span, .discard-pile-container span { /* Sin cambios */ }

        .deck-pile-source, .discard-pile-top-card-container {
            width: 85px;
            height: 120px;
            border: 2px dashed #fff;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .deck-pile-source { cursor: grab; }
        .deck-pile-source img { /* Para el dorso */
             width: 75px;
             height: 110px;
             /* border-radius: 5px; */
        }
        .deck-pile-source.disabled-source img,
        .discard-pile-top-card-container.disabled-source .card img {
            opacity: 0.5;
            cursor: not-allowed;
        }
         .deck-pile-source.disabled-source {
            cursor: not-allowed;
        }
        .deck-pile-source .card-count-display { /* Sin cambios */ }
        .discard-pile-top-card-container .card { /* Sin cambios */ }
        .discard-pile-top-card-container:empty { /* Sin cambios */ }

        .actions-area { /* Sin cambios */ }
        .game-messages { /* Sin cambios */ }
        button { /* Sin cambios */ }
        .scoreboard { /* Sin cambios */ }
        .modal { /* Sin cambios */ }
        .modal-content { /* Sin cambios */ }
        .round-summary-cards { /* Sin cambios */ }
        .round-summary-cards .card { width: 50px; height: 75px; }
        .round-summary-cards .card img { /* border-radius: 3px; */ }
        .melded img { border: 2px solid limegreen !important; }
        .unmelded img { border: 2px solid crimson !important; }

    </style>
</head>
<body>
    <div class="scoreboard"> <!-- ... --> </div>
    <div class="game-container"> <!-- ... --> </div>
    <div id="round-summary-modal" class="modal"> <!-- ... --> </div>

    <!-- Contenido HTML del body (scoreboard, game-container, modal) igual que antes -->
    <div class="scoreboard">
        <h2>Puntuación</h2>
        <p>Jugador: <span id="player-score">0</span></p>
        <p>CPU: <span id="cpu-score">0</span></p>
        <p>Ronda: <span id="round-number">1</span></p>
    </div>

    <div class="game-container">
        <h1>Chin Chón <small>(Poker - SVG Cards)</small></h1>

        <div id="cpu-area">
            <h3>Mano CPU (<span id="cpu-card-count">0</span> cartas)</h3>
            <div class="hand-area cpu-hand" id="cpu-hand"></div>
        </div>

        <div class="deck-pozo-area">
            <div class="deck-pile-container">
                <span>MAZO</span>
                <div class="deck-pile-source" id="deck-pile-source" draggable="true" title="Arrastra para robar del Mazo">
                </div>
            </div>
            <div class="discard-pile-container">
                <span>POZO (Arrastra carta aquí para descartar)</span>
                <div class="discard-pile-target hand-area" id="discard-pile-target">
                     <div class="discard-pile-top-card-container" id="discard-pile-top-card-container">
                     </div>
                </div>
            </div>
        </div>

         <div class="game-messages" id="game-message">Cargando juego...</div>

        <div id="player-area">
            <h3>Tu Mano (Arrastra para ordenar o al Pozo para descartar)</h3>
            <div class="hand-area player-hand-container" id="player-hand-container"></div>
        </div>

        <div class="actions-area" id="actions-area">
             <button id="btn-next-round" style="display:none;">Siguiente Ronda</button>
             <button id="btn-new-game" style="display:none;">Nuevo Juego</button>
        </div>
    </div>

    <div id="round-summary-modal" class="modal">
        <div class="modal-content">
            <h3 id="round-summary-title">Fin de la Ronda</h3>
            <div id="round-summary-jugador">
                <h4>Jugador:</h4>
                <p>Puntos esta ronda: <span id="summary-player-points-round">0</span></p>
                <p>Combinaciones:</p>
                <div id="summary-player-melds" class="round-summary-cards"></div>
                <p>Cartas sueltas:</p>
                <div id="summary-player-unmelded" class="round-summary-cards"></div>
            </div>
            <hr>
            <div id="round-summary-cpu">
                <h4>CPU:</h4>
                <p>Puntos esta ronda: <span id="summary-cpu-points-round">0</span></p>
                 <p>Combinaciones:</p>
                <div id="summary-cpu-melds" class="round-summary-cards"></div>
                <p>Cartas sueltas:</p>
                <div id="summary-cpu-unmelded" class="round-summary-cards"></div>
            </div>
            <p id="round-winner-message"></p>
            <button id="modal-close-button" class="modal-close-button">Continuar</button>
        </div>
    </div>


<script>
    // --- CONSTANTES PARA CARTAS DE POKER (Adaptadas para SVGs) ---
    const PALOS_POKER = ["Corazones", "Diamantes", "Treboles", "Picas"];

    // Nombres para construir URLs de SVGs (ej. del set de htdebeer)
    const VALOR_SVG_NOMBRE = {
        1: "ace", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "jack", 12: "queen", 13: "king"
    };
    const PALO_SVG_NOMBRE = {
        "Corazones": "hearts", "Diamantes": "diamonds", "Treboles": "clubs", "Picas": "spades"
    };
    // URL Base del set de SVGs de htdebeer (o el que elijas)
    const BASE_SVG_URL = "https://raw.githubusercontent.com/htdebeer/SVG-cards/master/playing-cards-svg-Pack-1.2/svg-cards/";
    // Para el dorso, podríamos usar un PNG si el set SVG no tiene uno fácil de nombrar, o si prefieres un diseño específico.
    const DORSO_CARTA_IMG_URL = "https://deckofcardsapi.com/static/img/blue_back.png"; // Mantenemos el PNG para el dorso por simplicidad

    // Constantes de puntuación y reglas del juego (sin cambios)
    const VALORES_DISPLAY_POKER = { 1: "A", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "J", 12: "Q", 13: "K" };
    const VALORES_NUMERICOS_POKER = { "A": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 11, "Q": 12, "K": 13 };
    const PUNTOS_CARTAS_POKER = { "A": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "10": 10, "J": 10, "Q": 10, "K": 10 };
    const LIMITE_PUNTOS_PARTIDA = -100; const PUNTOS_CHINCHON = -25; const PUNTOS_CERRAR_CON_CERO = -10;
    const MAX_PUNTOS_PARA_CERRAR = 5; const PENALIZACION_CORTE_FALLIDO = 25;

    // --- ESTADO DEL JUEGO (sin cambios) ---
    let mazo = []; let pozo = []; let manoJugador = []; let manoCPU = [];
    let puntuacionJugador = 0; let puntuacionCPU = 0; let rondaActual = 1;
    let turnoJugador = true; let juegoTerminado = false;
    let jugadorPuedeRobar = true; let jugadorDebeDescartar = false;

    // --- ELEMENTOS DEL DOM (declarados, se asignarán en DOMContentLoaded) ---
    let playerHandContainer, cpuHandElement, deckPileSourceElement, discardPileTargetElement,
        discardPileTopCardContainer, gameMessageElement, playerScoreElement, cpuScoreElement,
        roundNumberElement, cpuCardCountElement, actionsArea,
        btnNextRound, btnNewGame, roundSummaryModal, modalCloseButton;

    // --- VARIABLES DRAG AND DROP (sin cambios) ---
    let draggedItem = null; let draggedItemType = null; let draggedCardData = null;
    let placeholder = null;


    class Carta {
        constructor(valorNum, palo) {
            this.valorNum = valorNum; this.palo = palo;
            this.nombreValor = VALORES_DISPLAY_POKER[valorNum];
            this.puntos = PUNTOS_CARTAS_POKER[this.nombreValor];
            this.id = `${this.nombreValor}-${this.palo}-${Math.random().toString(16).slice(2)}`;

            // Construir el nombre del archivo SVG
            const valorNombreSVG = VALOR_SVG_NOMBRE[valorNum];
            const paloNombreSVG = PALO_SVG_NOMBRE[palo];
            this.imgUrl = `${BASE_SVG_URL}${valorNombreSVG}_of_${paloNombreSVG}.svg`;
             // Excepción para el 10 (algunos sets usan "10", otros "ten")
            if (valorNum === 10 && BASE_SVG_URL.includes("htdebeer")) { // Asumimos que este set puede usar "10" en vez de "ten"
                 // Si el set de htdebeer usa '10_of_diamonds.svg', no necesitamos cambiar 'ten'
                 // La URL de htdebeer ya usa '10', 'jack', 'queen', 'king'
            }
        }
        toString() { return `${this.nombreValor} de ${this.palo}`; }

        getHTML(isDraggable = false, isCPU = false) {
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card');
            cardDiv.dataset.id = this.id;
            cardDiv.draggable = isDraggable;

            const img = document.createElement('img');
            img.src = isCPU ? DORSO_CARTA_IMG_URL : this.imgUrl; // Usar el dorso PNG o el SVG de la carta
            img.alt = isCPU ? "Carta CPU" : this.toString();
            img.onerror = function() {
                console.warn("Error cargando SVG/imagen: " + this.src + ". Mostrando texto.");
                // Fallback de texto si el SVG no carga
                const valorTexto = VALORES_DISPLAY_POKER[this.valorNum];
                let paloTexto = '?';
                if (this.palo === "Corazones") paloTexto = '♥';
                else if (this.palo === "Diamantes") paloTexto = '♦';
                else if (this.palo === "Treboles") paloTexto = '♣';
                else if (this.palo === "Picas") paloTexto = '♠';

                cardDiv.innerHTML = `<div style="padding:5px; font-size:16px; text-align:center; color:black; background:white; border:1px solid black; width:100%; height:100%; display:flex; flex-direction:column; justify-content:space-around; align-items:center; box-sizing: border-box;"><span>${valorTexto}</span><span>${paloTexto}</span><span>${valorTexto}</span></div>`;
                cardDiv.style.width = '70px';
                cardDiv.style.height = '100px';
            }.bind(this); // 'this' se refiere a la instancia de Carta
            cardDiv.appendChild(img);

            if (isDraggable && !isCPU) {
                cardDiv.addEventListener('dragstart', handleDragStartPlayerCard);
                cardDiv.addEventListener('dragend', handleDragEndGeneral);
            }
            return cardDiv;
        }
    }

    // --- Resto de Funciones de Lógica del Juego (crearBaraja, repartirCartas, renderizar, actualizarUI, DnD, etc.) ---
    // La mayoría de estas funciones no necesitan cambiar su lógica interna, solo cómo se renderizan las cartas (ya cubierto en Carta.getHTML)

    function crearBaraja() { /* Sin cambios */ }
    function repartirCartas() { /* Sin cambios */ }
    function renderizarManoJugador() { /* Sin cambios */ }
    function renderizarManoCPU() { /* Sin cambios */ }
    function renderizarFuentesDeRoboYPozo() { /* Sin cambios */ }
    function actualizarUI() { /* Sin cambios */ }
    function handleDragStartPlayerCard(e) { /* Sin cambios */ }
    function handleDragStartSourceCard(e, cardData, type) { /* Sin cambios */ }
    function handleDragEndGeneral(e) { /* Sin cambios */ }
    playerHandContainer.addEventListener('dragover', (e) => { /* Sin cambios */ });
    playerHandContainer.addEventListener('dragleave', (e) => { /* Sin cambios */ });
    playerHandContainer.addEventListener('drop', (e) => { /* Sin cambios */ });
    function getDragAfterElementInPlayerHand(x) { /* Sin cambios */ }
    discardPileTargetElement.addEventListener('dragover', (e) => { /* Sin cambios */ });
    discardPileTargetElement.addEventListener('dragleave', (e) => { /* Sin cambios */ });
    discardPileTargetElement.addEventListener('drop', (e) => { /* Sin cambios */ });
    function cambiarTurno() { /* Sin cambios */ }
    function revisarMazoPozo() { /* Sin cambios */ }
    function ordenarMano(mano) { /* Sin cambios */ }
    function obtenerCombinacionesPosibles(mano) { /* Sin cambios */ }
    function evaluarManoCompleto(mano) { /* Sin cambios */ }
    function esChinChon(mano) { /* Sin cambios */ }
    function cpuDecideRobar(manoCpu, cartaPozo) { /* Sin cambios */ }
    function cpuEligeDescarte(manoCpuOriginal) { /* Sin cambios */ }
    function turnoCPU() { /* Sin cambios */ }
    function finalizarRonda(cerrador, hizoChinchon, empateTecnico = false) { /* Sin cambios */ }
    function mostrarCartasEnResumen(elementId, items, esMelded) { /* Sin cambios */ }
    function closeModal() { /* Sin cambios */ }
    function verificarFinPartida() { /* Sin cambios */ }
    function startNewRound() { /* Sin cambios */ }
    function asignarElementosDOM() { /* Sin cambios */ }
    function initGame() { /* Sin cambios */ }


    // COPIAR Y PEGAR AQUÍ LAS FUNCIONES JS DE LA RESPUESTA ANTERIOR
    // DESDE crearBaraja() HASTA initGame() INCLUSIVE.
    // La clase Carta ya está actualizada arriba.
    // Las funciones de renderizado ya usan la nueva Carta.getHTML()

    // Pegando las funciones para completitud (revisar si hay alguna pequeña adaptación necesaria):
    function crearBaraja() {
        mazo = [];
        for (const palo of PALOS_POKER) {
            for (const valorNum of Object.values(VALORES_NUMERICOS_POKER)) {
                 mazo.push(new Carta(valorNum, palo));
            }
        }
        for (let i = mazo.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [mazo[i], mazo[j]] = [mazo[j], mazo[i]];
        }
    }
    function repartirCartas() {
        manoJugador = []; manoCPU = []; pozo = [];
        for (let i = 0; i < 7; i++) {
            if (mazo.length > 0) manoJugador.push(mazo.pop());
            if (mazo.length > 0) manoCPU.push(mazo.pop());
        }
        if (mazo.length > 0) pozo.push(mazo.pop());
        else console.error("Mazo vacío al poner carta en pozo inicial.");
    }

    function renderizarManoJugador() {
        if (!playerHandContainer) return;
        playerHandContainer.innerHTML = '';
        manoJugador.forEach(carta => playerHandContainer.appendChild(carta.getHTML(true, false)));
    }
    function renderizarManoCPU() {
        if (!cpuHandElement || !cpuCardCountElement) return;
        cpuHandElement.innerHTML = '';
        manoCPU.forEach(carta => cpuHandElement.appendChild(carta.getHTML(false, true)));
        cpuCardCountElement.textContent = manoCPU.length;
    }

    function renderizarFuentesDeRoboYPozo() {
        if (!deckPileSourceElement || !discardPileTopCardContainer) return;
        deckPileSourceElement.innerHTML = '';
        if (mazo.length > 0) {
            const imgDorsoMazo = document.createElement('img');
            imgDorsoMazo.src = DORSO_CARTA_IMG_URL;
            imgDorsoMazo.alt = "Mazo de robo";
            deckPileSourceElement.appendChild(imgDorsoMazo);
            const countDiv = document.createElement('div');
            countDiv.classList.add('card-count-display');
            countDiv.textContent = mazo.length;
            deckPileSourceElement.appendChild(countDiv);
        } else {
            deckPileSourceElement.textContent = "Vacío";
        }
        deckPileSourceElement.classList.toggle('disabled-source', mazo.length === 0 || !turnoJugador || !jugadorPuedeRobar);
        deckPileSourceElement.draggable = turnoJugador && jugadorPuedeRobar && mazo.length > 0;

        discardPileTopCardContainer.innerHTML = '';
        if (pozo.length > 0) {
            const topCardPozo = pozo[pozo.length - 1];
            const cardElement = topCardPozo.getHTML(turnoJugador && jugadorPuedeRobar, false);
            discardPileTopCardContainer.appendChild(cardElement);
            if (turnoJugador && jugadorPuedeRobar) {
                cardElement.addEventListener('dragstart', (e) => handleDragStartSourceCard(e, topCardPozo, 'discardTop'));
                cardElement.addEventListener('dragend', handleDragEndGeneral);
            }
        } else {
            discardPileTopCardContainer.textContent = "Vacío";
        }
        discardPileTopCardContainer.classList.toggle('disabled-source', pozo.length === 0 || !turnoJugador || !jugadorPuedeRobar);
    }

    function actualizarUI() {
        if (!playerScoreElement) { console.error("UI no lista"); return; }
        renderizarManoJugador();
        renderizarManoCPU();
        renderizarFuentesDeRoboYPozo();
        playerScoreElement.textContent = puntuacionJugador;
        cpuScoreElement.textContent = puntuacionCPU;
        roundNumberElement.textContent = rondaActual;
        actionsArea.innerHTML = '';
        if (turnoJugador && !jugadorPuedeRobar && !jugadorDebeDescartar && !juegoTerminado) {
            const { puntosSueltos, esChinchon } = evaluarManoCompleto(manoJugador);
            if (esChinchon || puntosSueltos <= MAX_PUNTOS_PARA_CERRAR) {
                const btnCerrar = document.createElement('button');
                btnCerrar.textContent = esChinchon ? "¡Cerrar con CHINCHÓN!" : `Cerrar Ronda (${puntosSueltos} pts)`;
                btnCerrar.onclick = () => finalizarRonda("Jugador", esChinchon);
                actionsArea.appendChild(btnCerrar);
                const btnPasar = document.createElement('button');
                btnPasar.textContent = "Pasar Turno";
                btnPasar.onclick = cambiarTurno;
                actionsArea.appendChild(btnPasar);
            }
        }
        btnNextRound.style.display = 'none';
        btnNewGame.style.display = juegoTerminado ? 'inline-block' : 'none';
        if (juegoTerminado && !actionsArea.contains(btnNewGame)) actionsArea.appendChild(btnNewGame);
    }

    function handleDragStartPlayerCard(e) {
        if (!turnoJugador || manoJugador.length === 0) { e.preventDefault(); return; }
        draggedItem = e.target.closest('.card');
        if (!draggedItem) { e.preventDefault(); return; }
        draggedItemType = 'playerCard';
        draggedCardData = manoJugador.find(c => c.id === draggedItem.dataset.id);
        if (!draggedCardData) { e.preventDefault(); return; }
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', draggedCardData.id);
        draggedItem.classList.add('dragging');
        if (!placeholder) {
            placeholder = document.createElement('div');
            placeholder.classList.add('placeholder');
        }
    }
    function handleDragStartSourceCard(e, cardData, type) {
        if (!turnoJugador || !jugadorPuedeRobar) { e.preventDefault(); return; }
        draggedItem = e.target.closest('.card') || e.target.closest('.deck-pile-source');
        if (!draggedItem) { e.preventDefault(); return; }
        draggedItemType = type;
        draggedCardData = cardData;
        e.dataTransfer.effectAllowed = 'copy';
        e.dataTransfer.setData('text/plain', type);
        draggedItem.classList.add('dragging');
    }
    function handleDragEndGeneral(e) {
        if (draggedItem) draggedItem.classList.remove('dragging');
        if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
        if (playerHandContainer) playerHandContainer.classList.remove('drag-over');
        if (discardPileTargetElement) discardPileTargetElement.classList.remove('drag-over');
        draggedItem = null; draggedItemType = null; draggedCardData = null;
    }
    function getDragAfterElementInPlayerHand(x) {
        const draggableElements = [...playerHandContainer.querySelectorAll('.card:not(.dragging):not(.placeholder)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect(); const offset = x - box.left - box.width / 2;
            if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
            else return closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function cambiarTurno() {
        turnoJugador = !turnoJugador; jugadorPuedeRobar = true; jugadorDebeDescartar = false;
        if(actionsArea) actionsArea.innerHTML = '';
        if (juegoTerminado) { actualizarUI(); return; }
        if (!turnoJugador) {
            gameMessageElement.textContent = "Turno de la CPU..."; actualizarUI(); setTimeout(turnoCPU, 1500);
        } else {
            gameMessageElement.textContent = "Tu turno. Arrastra para robar."; revisarMazoPozo(); actualizarUI();
        }
    }
    function revisarMazoPozo() {
        let mazoCambiado = false;
        if (mazo.length === 0 && pozo.length > 1) {
            if(gameMessageElement) gameMessageElement.textContent = "Mazo agotado. Barajando pozo...";
            const ultimaPozo = pozo.pop(); mazo = [...pozo]; pozo = [ultimaPozo];
            for (let i = mazo.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [mazo[i], mazo[j]] = [mazo[j], mazo[i]]; }
            mazoCambiado = true; if(gameMessageElement) gameMessageElement.textContent = "Mazo repuesto. Tu turno.";
        } else if (mazo.length === 0 && pozo.length <=1 && turnoJugador && jugadorPuedeRobar) {
            if(gameMessageElement) gameMessageElement.textContent = "¡Sin cartas para robar! Ronda en empate."; finalizarRonda(null, false, true); return;
        }
        if (mazoCambiado) actualizarUI();
    }
    function ordenarMano(mano) { return mano.slice().sort((a, b) => (a.palo < b.palo) ? -1 : (a.palo > b.palo) ? 1 : a.valorNum - b.valorNum); }
    function obtenerCombinacionesPosibles(mano) {
        const combinaciones = []; const manoCopia = mano.slice();
        manoCopia.sort((a, b) => (a.palo < b.palo) ? -1 : (a.palo > b.palo) ? 1 : a.valorNum - b.valorNum);
        for (let i = 0; i < manoCopia.length; i++) {
            let escaleraActual = [manoCopia[i]];
            for (let j = i + 1; j < manoCopia.length; j++) {
                if (manoCopia[j].palo === escaleraActual[0].palo && manoCopia[j].valorNum === escaleraActual[escaleraActual.length - 1].valorNum + 1) {
                    escaleraActual.push(manoCopia[j]);
                } else if (manoCopia[j].palo !== escaleraActual[0].palo) break;
            }
            if (escaleraActual.length >= 3) {
                for (let len = 3; len <= escaleraActual.length; len++) {
                    for (let start = 0; start <= escaleraActual.length - len; start++) {
                        combinaciones.push(escaleraActual.slice(start, start + len));
                    }
                }
            }
        }
        const cartasPorValor = {};
        mano.forEach(carta => { (cartasPorValor[carta.valorNum] = cartasPorValor[carta.valorNum] || []).push(carta); });
        for (const valor in cartasPorValor) {
            if (cartasPorValor[valor].length >= 3) combinaciones.push(cartasPorValor[valor].slice(0, 3));
            if (cartasPorValor[valor].length === 4) combinaciones.push(cartasPorValor[valor].slice(0, 4));
        }
        let combinacionesUnicas = []; combinaciones.sort((a,b) => b.length - a.length);
        for (const comb of combinaciones) {
            if (!combinacionesUnicas.some(unica => comb.every(c => unica.find(u => u.id === c.id)))) {
                combinacionesUnicas.push(comb);
            }
        }
        return combinacionesUnicas;
    }
    function evaluarManoCompleto(mano) {
        if (mano.length === 0) return { combinacionesElegidas: [], cartasSueltas: [], puntosSueltos: 0, esChinchon: false };
        const chinchon = esChinChon(mano);
        if (chinchon) return { combinacionesElegidas: [ordenarMano(mano.slice())], cartasSueltas: [], puntosSueltos: 0, esChinchon: true };
        let mejorResultado = { combinacionesElegidas: [], cartasSueltas: mano.slice(), puntosSueltos: mano.reduce((sum, c) => sum + c.puntos, 0), esChinchon: false };
        const todasCombinaciones = obtenerCombinacionesPosibles(mano.slice());
        function encontrarMejorConfig(idxCombActual, cartasYaUsadasIds, configActual) {
            if (idxCombActual === todasCombinaciones.length) {
                let currentSueltas = mano.filter(c => !cartasYaUsadasIds.has(c.id));
                let currentPuntos = currentSueltas.reduce((sum, c) => sum + c.puntos, 0);
                if (currentPuntos < mejorResultado.puntosSueltos || (currentPuntos === mejorResultado.puntosSueltos && configActual.reduce((s,m)=>s+m.length,0) > mejorResultado.combinacionesElegidas.reduce((s,m)=>s+m.length,0) )) {
                    mejorResultado = { combinacionesElegidas: configActual.slice(), cartasSueltas: currentSueltas, puntosSueltos: currentPuntos, esChinchon: false };
                } return;
            }
            encontrarMejorConfig(idxCombActual + 1, new Set(cartasYaUsadasIds), configActual.slice()); 
            const combIntento = todasCombinaciones[idxCombActual]; let sePuedeUsar = true;
            for (const cartaDeComb of combIntento) if (cartasYaUsadasIds.has(cartaDeComb.id)) { sePuedeUsar = false; break; }
            if (sePuedeUsar) {
                const nuevasCartasUsadasIds = new Set(cartasYaUsadasIds); combIntento.forEach(c => nuevasCartasUsadasIds.add(c.id));
                const nuevaConfigActual = configActual.slice(); nuevaConfigActual.push(combIntento);
                encontrarMejorConfig(idxCombActual + 1, nuevasCartasUsadasIds, nuevaConfigActual);
            }
        }
        if(todasCombinaciones.length > 0) encontrarMejorConfig(0, new Set(), []);
        return mejorResultado;
    }
    function esChinChon(mano) {
        if (mano.length !== 7) return false; const manoOrd = ordenarMano(mano.slice());
        if (manoOrd.length === 0) return false; 
        const primerPalo = manoOrd[0].palo;
        for (let i = 0; i < manoOrd.length; i++) {
            if (manoOrd[i].palo !== primerPalo) return false;
            if (i > 0 && manoOrd[i].valorNum !== manoOrd[i-1].valorNum + 1) return false;
        } return true;
    }
    function cpuDecideRobar(manoCpu, cartaPozo) {
        if (!cartaPozo) return "mazo";
        if (manoCpu.length === 6) if (esChinChon([...manoCpu, cartaPozo])) return "pozo";
        const { puntosSueltos: puntosActuales } = evaluarManoCompleto(manoCpu);
        let mejorPuntosConPozo = Infinity; const manoConPozo = [...manoCpu, cartaPozo];
        if (manoConPozo.length === 7) { // Si roba, tendrá 7. Evaluamos esta mano de 7.
             mejorPuntosConPozo = evaluarManoCompleto(manoConPozo).puntosSueltos;
        } else if (manoConPozo.length > 7) { // Si ya tenía 7 y roba (error de flujo) o para CPU con más cartas.
            for (let i = 0; i < manoConPozo.length; i++) { // Evalúa descartando cada una de las 8
                const { puntosSueltos: p } = evaluarManoCompleto(manoConPozo.filter((_, idx) => idx !== i));
                if (p < mejorPuntosConPozo) mejorPuntosConPozo = p;
            }
        }
        if (mejorPuntosConPozo < puntosActuales - 3 || (mejorPuntosConPozo <= MAX_PUNTOS_PARA_CERRAR && puntosActuales > MAX_PUNTOS_PARA_CERRAR)) return "pozo";
        return "mazo";
    }
    function cpuEligeDescarte(manoCpuOriginal) {
        let manoCpu = manoCpuOriginal.slice(); let cartaADescartar = null; let minPuntosSueltosPostDescarte = Infinity;
        if (manoCpu.length <= 1) return manoCpu[0] || null;
        for (let i = 0; i < manoCpu.length; i++) {
            const cartaPotencialDescarte = manoCpu[i];
            const { puntosSueltos } = evaluarManoCompleto(manoCpu.filter(c => c.id !== cartaPotencialDescarte.id));
            if (puntosSueltos < minPuntosSueltosPostDescarte || (puntosSueltos === minPuntosSueltosPostDescarte && (cartaADescartar === null || cartaPotencialDescarte.puntos > cartaADescartar.puntos))) {
                minPuntosSueltosPostDescarte = puntosSueltos; cartaADescartar = cartaPotencialDescarte;
            }
        } return cartaADescartar || manoCpu[Math.floor(Math.random() * manoCpu.length)];
    }
    function turnoCPU() {
         if (juegoTerminado) return; gameMessageElement.textContent = "CPU está pensando...";
        setTimeout(() => {
            revisarMazoPozo();
            if (mazo.length === 0 && pozo.length <=1 && !turnoJugador) { finalizarRonda(null, false, true); return; }
            const cartaDelPozo = pozo.length > 0 ? pozo[pozo.length - 1] : null;
            const decisionRobo = cpuDecideRobar(manoCPU, cartaDelPozo); let cartaRobadaCPU;
            if (decisionRobo === "pozo" && cartaDelPozo) {
                cartaRobadaCPU = pozo.pop(); gameMessageElement.textContent = `CPU robó ${cartaRobadaCPU} del pozo.`;
            } else {
                if (mazo.length === 0) { finalizarRonda(null, false, true); return; }
                cartaRobadaCPU = mazo.pop(); gameMessageElement.textContent = "CPU robó del mazo.";
            }
            manoCPU.push(cartaRobadaCPU);
            setTimeout(() => {
                let cartaParaDescartarCPU = cpuEligeDescarte(manoCPU);
                if (!cartaParaDescartarCPU && manoCPU.length > 0) cartaParaDescartarCPU = manoCPU[0];
                else if (!cartaParaDescartarCPU && manoCPU.length === 0) { cambiarTurno(); return; }

                const indexDescarte = manoCPU.findIndex(c => c.id === cartaParaDescartarCPU.id); 
                if (indexDescarte > -1) {
                    const [descartadaCPU] = manoCPU.splice(indexDescarte, 1); 
                    pozo.push(descartadaCPU); 
                    gameMessageElement.textContent = `CPU descartó ${descartadaCPU}.`;
                } else { if(manoCPU.length > 0) { const fb = manoCPU.pop(); pozo.push(fb); gameMessageElement.textContent = `CPU descartó (fb) ${fb}.`;}}
                actualizarUI();
                const { esChinchon: cpuChinchon, puntosSueltos: puntosCPUSueltos } = evaluarManoCompleto(manoCPU);
                if (cpuChinchon) finalizarRonda("CPU", true);
                else if (puntosCPUSueltos <= MAX_PUNTOS_PARA_CERRAR - 2) finalizarRonda("CPU", false);
                else cambiarTurno();
            }, 1000);
        }, 1000);
    }
    function finalizarRonda(cerrador, hizoChinchon, empateTecnico = false) {
        jugadorPuedeRobar = false; jugadorDebeDescartar = false;
        let evalJugador = evaluarManoCompleto(manoJugador); let evalCPU = evaluarManoCompleto(manoCPU);
        let puntosRondaJugador = evalJugador.puntosSueltos; let puntosRondaCPU = evalCPU.puntosSueltos;
        let mensajeGanadorRonda = "";
        if (empateTecnico) {
            puntuacionJugador += puntosRondaJugador; puntuacionCPU += puntosRondaCPU;
            mensajeGanadorRonda = "Ronda en empate técnico.";
        } else if (cerrador === "Jugador") {
            if (hizoChinchon) { puntuacionJugador += PUNTOS_CHINCHON; puntuacionCPU += puntosRondaCPU; mensajeGanadorRonda = "¡Jugador hizo ChinChón!"; }
            else {
                puntuacionJugador += (puntosRondaJugador === 0) ? PUNTOS_CERRAR_CON_CERO : puntosRondaJugador;
                if (puntosRondaCPU < puntosRondaJugador && puntosRondaJugador > 0) { puntuacionJugador += PENALIZACION_CORTE_FALLIDO; mensajeGanadorRonda = `Jugador cerró, CPU tenía menos (${puntosRondaCPU}). ¡Penalización!`; }
                else mensajeGanadorRonda = `Jugador cerró con ${puntosRondaJugador} pts.`;
                puntuacionCPU += puntosRondaCPU;
            }
        } else if (cerrador === "CPU") {
            if (hizoChinchon) { puntuacionCPU += PUNTOS_CHINCHON; puntuacionJugador += puntosRondaJugador; mensajeGanadorRonda = "¡CPU hizo ChinChón!"; }
            else {
                puntuacionCPU += (puntosRondaCPU === 0) ? PUNTOS_CERRAR_CON_CERO : puntosRondaCPU;
                if (puntosRondaJugador < puntosRondaCPU && puntosRondaCPU > 0) { puntuacionCPU += PENALIZACION_CORTE_FALLIDO; mensajeGanadorRonda = `CPU cerró, Jugador tenía menos (${puntosRondaJugador}). ¡Penalización!`; }
                else mensajeGanadorRonda = `CPU cerró con ${puntosRondaCPU} pts.`;
                puntuacionJugador += puntosRondaJugador;
            }
        }
        document.getElementById('summary-player-points-round').textContent = `${puntosRondaJugador}`;
        mostrarCartasEnResumen('summary-player-melds', evalJugador.combinacionesElegidas, true);
        mostrarCartasEnResumen('summary-player-unmelded', evalJugador.cartasSueltas, false);
        document.getElementById('summary-cpu-points-round').textContent = `${puntosRondaCPU}`;
        mostrarCartasEnResumen('summary-cpu-melds', evalCPU.combinacionesElegidas, true);
        mostrarCartasEnResumen('summary-cpu-unmelded', evalCPU.cartasSueltas, false);
        document.getElementById('round-winner-message').textContent = mensajeGanadorRonda;
        roundSummaryModal.style.display = "flex";
        actualizarUI(); verificarFinPartida();
    }
    function mostrarCartasEnResumen(elementId, items, esMelded) {
        const container = document.getElementById(elementId); container.innerHTML = '';
        if (!items || items.length === 0) { container.textContent = "Ninguna"; return; }
        if (esMelded) {
            items.forEach(grupoDeCartas => {
                 const groupDiv = document.createElement('div'); groupDiv.style.display='flex'; groupDiv.style.marginRight = '5px'; groupDiv.style.marginBottom = '2px';
                 grupoDeCartas.forEach(carta => { 
                    const cardEl = carta.getHTML(false,false);
                    cardEl.classList.add('melded');
                    cardEl.style.width = '50px'; cardEl.style.height = '75px';
                    groupDiv.appendChild(cardEl); 
                });
                container.appendChild(groupDiv);
            });
        } else { 
            items.forEach(carta => { 
                const cardEl = carta.getHTML(false,false); 
                cardEl.classList.add('unmelded');
                cardEl.style.width = '50px'; cardEl.style.height = '75px';
                container.appendChild(cardEl); 
            }); 
        }
    }
    function closeModal() {
        roundSummaryModal.style.display = "none";
        actionsArea.innerHTML = '';
        if (juegoTerminado) {
            if (btnNewGame) { btnNewGame.style.display = 'inline-block'; if (!actionsArea.contains(btnNewGame)) actionsArea.appendChild(btnNewGame); }
        } else {
             if (btnNextRound) { btnNextRound.style.display = 'inline-block'; if (!actionsArea.contains(btnNextRound)) actionsArea.appendChild(btnNextRound); }
        }
    }
    function verificarFinPartida() {
         if (puntuacionJugador <= LIMITE_PUNTOS_PARTIDA || puntuacionCPU <= LIMITE_PUNTOS_PARTIDA) {
            juegoTerminado = true; let mensajeFinal = "¡Fin de la Partida! ";
            if (puntuacionJugador < puntuacionCPU) { mensajeFinal += (puntuacionJugador <= LIMITE_PUNTOS_PARTIDA && puntuacionCPU > LIMITE_PUNTOS_PARTIDA) ? "¡La CPU superó el límite! ¡GANASTE!" : "¡GANASTE!"; }
            else if (puntuacionCPU < puntuacionJugador) { mensajeFinal += (puntuacionCPU <= LIMITE_PUNTOS_PARTIDA && puntuacionJugador > LIMITE_PUNTOS_PARTIDA) ? "¡Superaste el límite! ¡GANA LA CPU!" : "¡GANA LA CPU!"; }
            else { mensajeFinal += "¡EMPATE!"; }
            gameMessageElement.textContent = mensajeFinal;
            document.getElementById('modal-close-button').textContent = "Ver Resultados Finales";
            actionsArea.innerHTML = '';
            btnNewGame.style.display = 'inline-block';
            actionsArea.appendChild(btnNewGame);
            btnNextRound.style.display = 'none';
        }
    }
    function startNewRound() {
        if (juegoTerminado) return; rondaActual++;
        mazo = []; pozo = []; manoJugador = []; manoCPU = [];
        jugadorPuedeRobar = true; jugadorDebeDescartar = false;
        turnoJugador = (rondaActual % 2 === 1);
        crearBaraja(); repartirCartas();
        gameMessageElement.textContent = turnoJugador ? "Tu turno. Arrastra para robar." : "Turno de la CPU...";
        actionsArea.innerHTML = '';
        btnNextRound.style.display = 'none'; btnNewGame.style.display = 'none';
        if (!actionsArea.contains(btnNextRound)) actionsArea.appendChild(btnNextRound);
        if (!actionsArea.contains(btnNewGame)) actionsArea.appendChild(btnNewGame);
        actualizarUI();
        if (!turnoJugador) setTimeout(turnoCPU, 1500);
    }
    function asignarElementosDOM() {
        playerHandContainer = document.getElementById('player-hand-container');
        cpuHandElement = document.getElementById('cpu-hand');
        deckPileSourceElement = document.getElementById('deck-pile-source');
        discardPileTargetElement = document.getElementById('discard-pile-target');
        discardPileTopCardContainer = document.getElementById('discard-pile-top-card-container');
        gameMessageElement = document.getElementById('game-message');
        playerScoreElement = document.getElementById('player-score');
        cpuScoreElement = document.getElementById('cpu-score');
        roundNumberElement = document.getElementById('round-number');
        cpuCardCountElement = document.getElementById('cpu-card-count');
        actionsArea = document.getElementById('actions-area');
        btnNextRound = document.getElementById('btn-next-round');
        btnNewGame = document.getElementById('btn-new-game');
        roundSummaryModal = document.getElementById('round-summary-modal');
        modalCloseButton = document.getElementById('modal-close-button');

        btnNextRound.onclick = startNewRound;
        btnNewGame.onclick = initGame;
        modalCloseButton.onclick = closeModal;

        deckPileSourceElement.addEventListener('dragend', handleDragEndGeneral);
        playerHandContainer.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = (draggedItemType === 'deck' || draggedItemType === 'discardTop') ? 'copy' : 'move'; playerHandContainer.classList.add('drag-over'); if (draggedItemType === 'playerCard' && placeholder) { const afterElement = getDragAfterElementInPlayerHand(e.clientX); if (afterElement == null) playerHandContainer.appendChild(placeholder); else playerHandContainer.insertBefore(placeholder, afterElement);}});
        playerHandContainer.addEventListener('dragleave', (e) => { if (!playerHandContainer.contains(e.relatedTarget)) { playerHandContainer.classList.remove('drag-over'); if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);}});
        playerHandContainer.addEventListener('drop', (e) => { e.preventDefault(); playerHandContainer.classList.remove('drag-over'); if (draggedItemType === 'deck') { if (mazo.length > 0 && turnoJugador && jugadorPuedeRobar) { const cartaRobada = mazo.pop(); manoJugador.push(cartaRobada); jugadorPuedeRobar = false; jugadorDebeDescartar = true; gameMessageElement.textContent = `Robaste del mazo. Arrastra para descartar.`; actualizarUI(); }} else if (draggedItemType === 'discardTop') { if (pozo.length > 0 && turnoJugador && jugadorPuedeRobar && draggedCardData) { pozo.pop(); manoJugador.push(draggedCardData); jugadorPuedeRobar = false; jugadorDebeDescartar = true; gameMessageElement.textContent = `Robaste ${draggedCardData} del Pozo. Arrastra para descartar.`; actualizarUI(); }} else if (draggedItemType === 'playerCard') { const draggedCardId = draggedCardData.id; const originalIndex = manoJugador.findIndex(c => c.id === draggedCardId); if (originalIndex === -1) return; const [movedCard] = manoJugador.splice(originalIndex, 1); let newIndex = -1; if (placeholder && placeholder.parentNode === playerHandContainer) newIndex = Array.from(playerHandContainer.children).indexOf(placeholder); else { const afterElement = getDragAfterElementInPlayerHand(e.clientX); if(afterElement === null) newIndex = manoJugador.length; else newIndex = manoJugador.findIndex(c => c.id === afterElement.dataset.id); } if (newIndex === -1) newIndex = manoJugador.length; manoJugador.splice(newIndex, 0, movedCard); if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder); renderizarManoJugador(); }});
        discardPileTargetElement.addEventListener('dragover', (e) => { if (draggedItemType === 'playerCard' && turnoJugador && jugadorDebeDescartar) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; discardPileTargetElement.classList.add('drag-over'); }});
        discardPileTargetElement.addEventListener('dragleave', (e) => { if (!discardPileTargetElement.contains(e.relatedTarget)) discardPileTargetElement.classList.remove('drag-over'); });
        discardPileTargetElement.addEventListener('drop', (e) => { e.preventDefault(); discardPileTargetElement.classList.remove('drag-over'); if (draggedItemType === 'playerCard' && turnoJugador && jugadorDebeDescartar) { const cartaDescartadaId = draggedCardData.id; const index = manoJugador.findIndex(c => c.id === cartaDescartadaId); if (index > -1 && manoJugador.length === 8) { const [descartada] = manoJugador.splice(index, 1); pozo.push(descartada); jugadorDebeDescartar = false; gameMessageElement.textContent = `Descartaste ${descartada}.`; actualizarUI(); const { esChinchon, puntosSueltos } = evaluarManoCompleto(manoJugador); if (!(esChinchon || puntosSueltos <= MAX_PUNTOS_PARA_CERRAR)) { setTimeout(cambiarTurno, 300); }} else if (manoJugador.length !== 8) { gameMessageElement.textContent = "Debes tener 8 cartas para descartar.";}}});
    }
    function initGame() {
        puntuacionJugador = 0; puntuacionCPU = 0; rondaActual = 0;
        juegoTerminado = false; turnoJugador = true;
        if(actionsArea) actionsArea.innerHTML = '';
        if (btnNextRound && !actionsArea.contains(btnNextRound)) actionsArea.appendChild(btnNextRound);
        if (btnNewGame && !actionsArea.contains(btnNewGame)) actionsArea.appendChild(btnNewGame);
        if(btnNextRound) btnNextRound.style.display = 'none';
        if(btnNewGame) btnNewGame.style.display = 'none';
        startNewRound();
    }

    // --- INICIAR JUEGO ---
    document.addEventListener('DOMContentLoaded', () => {
        asignarElementosDOM();
        initGame();
    });

</script>
</body>
</html>